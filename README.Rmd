---
output:
  md_document:
    variant: markdown_github
---
```{r include=FALSE}
knitr::opts_chunk$set(message=FALSE)
```


```{r}

library(pacman)
pacman::p_load(fredr, tidyverse, lubridate, tsibble, dplyr, tseries, grid,gridExtra, sparsevar, tsDyn)


```



```{r}

FRED_API_KEY <- fredr_set_key("d3c88549b884b18ff71b2541742bd179")

```

```{r}
FFR_eff_nsa <- fredr(
  series_id = "BOGZ1FL072052006Q",
  observation_start = as.Date("1980-01-01"),
  observation_end = as.Date("2021-07-01")
) |> select(date, value) |> rename(FFR = value)

```

```{r}

CPI <- fredr(
  series_id = "CPALTT01USQ661S",
  observation_start = as.Date("1980-01-01"),
  observation_end = as.Date("2021-07-01")
) |> select(date, value)|> rename(CPI = value)

```


```{r}


GDP <- fredr(
  series_id = "GDPC1",
  observation_start = as.Date("1980-01-01"),
  observation_end = as.Date("2021-07-01")
) |> select(date, value)|> rename(GDP = value)

```


```{r}



M1 <- fredr(
  series_id = "M1SL",
  observation_start = as.Date("1980-01-01"),
  observation_end = as.Date("2021-07-01"),
  frequency = "q") |> select(date, value)|> rename(M1 = value)




```


```{r}

## NB NB NB Notice the last date, make sure all variables have same nimber of observations

Oil_prices1 <- fredr(
  series_id = "POILBREUSDQ",
  observation_start = as.Date("1990-01-01"),
  observation_end = as.Date("2022-01-01")
) |> select(date, value)

Oil_prices2 <- fredr(
  series_id = "OILPRICE",
  observation_start = as.Date("1980-01-01"),
  observation_end = as.Date("1989-11-01"),
  frequency = "q"
) |> select(date, value)

Oil_prices <- bind_rows(Oil_prices2, Oil_prices1) |> rename(Oil=value)

```

```{r}



Exchange_1 <- fredr(
  series_id = "DTWEXAFEGS",
  observation_start = as.Date("2006-01-02"),
  observation_end = as.Date("2021-07-01"),
  frequency = "q") |> select(date, value)


Exchange_2 <- fredr(
  series_id = "DTWEXM",
  observation_start = as.Date("1980-01-01"),
  observation_end = as.Date("2005-10-01"),
  frequency = "q") |> select(date, value)

Exchange <- bind_rows(Exchange_1, Exchange_2) |> rename(Exchange = value)
    
    
    
```

```{r}

df <- bind_cols(FFR_eff_nsa, CPI |> select(CPI), GDP|> select(GDP), M1|> select(M1), Exchange|> select(Exchange), Oil_prices|> select(Oil))

df_trimmed <- df |> filter(date <= lubridate::ymd(20031001))


df1 <- df |> mutate(lCPI = log(CPI), lGDP = log(GDP), lM1 = log(M1), lExchange = log(Exchange), lOil = log(Oil), realM1 = (lM1-lCPI), infl = lCPI - lag(lCPI)) |> fill( infl, .direction ="up")




interestrate_tr <- ts(df1$FFR, start=c(1980,1), end=c(2003, 4), freq=4)
price_tr <- ts(df1$lCPI, start=c(1980,1), end=c(2003, 4), freq=4)
realGDP_tr <- ts(df1$lGDP, start=c(1980,1), end=c(2003, 4), freq=4)
exchangerate_tr <- ts(df1$lExchange, start=c(1980,1), end=c(2003, 4), freq=4)
oilprice_tr <- ts(df1$lOil, start=c(1980,1), end=c(2003, 4), freq=4)
monetaryaggregate_tr <- ts(df1$lM1, start=c(1980,1), end=c(2003, 4), freq=4)
real_monetaryaggregate_tr <- ts(df1$realM1, start=c(1980,1), end=c(2003, 4), freq=4)   #transformation to real monetary aggregate
inflation_tr <- ts(df1$infl, start=c(1980,1), end=c(2003, 4), freq=4)

interestrate <- ts(df1$FFR, start=c(1980,1), end=c(2021, 3), freq=4)
price <- ts(df1$lCPI, start=c(1980,1), end=c(2021, 3), freq=4)
realGDP <- ts(df1$lGDP, start=c(1980,1), end=c(2021, 3), freq=4)
exchangerate <- ts(df1$lExchange, start=c(1980,1), end=c(2021, 3), freq=4)
oilprice <- ts(df1$lOil, start=c(1980,1), end=c(2021, 3), freq=4)
monetaryaggregate <- ts(df1$lM1, start=c(1980,1), end=c(2021, 3), freq=4)
real_monetaryaggregate <- ts(df1$realM1, start=c(1980,1), end=c(2021, 3), freq=4)   #transformation to real monetary aggregate
inflation <- ts(df1$infl, start=c(1980,1), end=c(2021, 3), freq=4)
    
D_interestrate_tr <- diff(interestrate_tr)
D_price_tr <- diff(price_tr)
D_realGDP_tr <- diff(realGDP_tr)
D_exchangerate_tr <- diff(exchangerate_tr)
D_oilprice_tr <- diff(oilprice_tr)
D_monetaryaggregate_tr <- diff(monetaryaggregate_tr)
D_real_monetaryaggregate_tr <- diff(real_monetaryaggregate_tr)
D_inflation_tr <- diff(inflation_tr)

```


# Johansen's Methodology for Modeling Cointegration

1. Select the specification of the deterministic component. Here the $\bm{\Phi}_t \bm{D}_t= \bm{\mu}_t = \bm{\mu}_0 + \bm{\mu}_1 t$ term contains all deterministic parts, i.e. constants and trends. 
2. Pre-test the variables to conclude that they are (or may be) $I(1)$.
3. Estimate the unrestricted VAR in levels and check the adequacy of the model specification.
4. Impose the number of cointegrating relationships $r$ and execute normalization as necessary.
5. Estimate the resulting (reduced-rank) cointegrated VECM, interpret the economic dynamics of the model, and test further hypothesized restrictions.

## Step 1: Select the specification of the deterministic component.

```{r}

df1_tidy <- df1 |> dplyr::select(date,FFR, lCPI, lGDP, lM1, lExchange, lOil, infl, realM1) |> pivot_longer(cols = c(FFR, lCPI, lGDP, lM1, lExchange, lOil, infl,realM1), names_to = "Variable", values_to = "Value") |> arrange(date)

gggg <- df1_tidy |> ggplot() +
    geom_line(aes(x = date, y = Value), alpha = 0.8, 
    size = 0.5) + 
    theme_bw() + theme(legend.position = "none") + labs(x = "", 
    y = "Prices", title = "TRI of Brics Countries", subtitle = "Total Return Index using net dividends reinvested", 
    caption = "Note:\nBloomberg data used") +
    facet_wrap(~Variable, scales = "free_y") 
    

```

## Pre-test the variables to conclude that they are (or may be) $I(1)$

### Augmented Dickey-Fuller (ADF) test for unit roots

```{r}

adf_interestrate_tr <- ur.df(interestrate_tr, type = "trend", selectlags = c("AIC")) #fail to reject null of no unit root
adf_price_tr <- ur.df(price_tr, type = "trend", selectlags = c("AIC")) #fail to reject null of no unit root
adf_realGDP_tr <- ur.df(realGDP_tr, type = "trend", selectlags = c("AIC")) # fail ...
adf_oilprice_tr <- ur.df(oilprice_tr, type = "trend", selectlags = c("AIC")) #
adf_interestrate_tr <- ur.df(interestrate_tr, type = "trend", selectlags = c("AIC"))
adf_monetaryaggregate_tr  <- ur.df(monetaryaggregate_tr, type = "trend", selectlags = c("AIC"))


```

### Augmented Dickey-Fuller (ADF) test for order of integration

```{r}

adf_D_interestrate_tr <- ur.df(D_interestrate_tr, selectlags = c("AIC")) #I(1)
adf_D_price_tr <- ur.df(D_price_tr, selectlags = c("AIC")) #fail to reject null of no unit root only at the 1% sign level #I(2)
adf_D_realGDP_trr <- ur.df(D_realGDP_tr, selectlags = c("AIC")) #I(1)
adf_D_exchangerate_tr <- ur.df(D_exchangerate_tr, selectlags = c("AIC")) #I(1)
adf_D_oilprice_tr <- ur.df(D_oilprice_tr, selectlags = c("AIC")) #I(1)
adf_D_monetaryaggregate_tr <- ur.df(D_monetaryaggregate_tr, selectlags = c("AIC")) #fail to reject null of no unit root only at the 1% sign level

## Now lets deal with the problem of the monetary aggregate I(2) be transforming it to the real monetary aggregate (mt - pt) and to inflation (change in price)

adf_real_monetaryaggregate_tr <- ur.df(real_monetaryaggregate_tr, type = "trend", selectlags = c("AIC")) #fail to reject null of no unit root

adf_D_real_montaryaggregate_tr <- ur.df(D_real_monetaryaggregate_tr , selectlags = c("AIC")) #reject the null, Therefore is I(1)

adf_inflation_tr <- ur.df(inflation_tr,selectlags = c("AIC")) #fail to reject the null of no unit root

D_adf_inflation_tr <- ur.df(D_inflation_tr,selectlags = c("AIC")) #reject the null. Thus inflation is I(1)

```

## Estimate the unrestricted VAR in levels and check the adequacy of the model specification.


```{r, echo = FALSE}
VAR1 <- cbind(real_monetaryaggregate_tr, interestrate_tr, realGDP_tr, inflation_tr, exchangerate_tr, oilprice_tr)
colnames(VAR1) <- cbind("RealMonetaryAggregate", "InterestRate", "RealGDP", "Inflation", "ExchangeRate", "OilPrice")
#In the same order as the A matrix


VAR2 <- cbind(realGDP_tr, oilprice_tr, interestrate_tr, inflation_tr,exchangerate_tr ,real_monetaryaggregate_tr)
#In a similar order to the cointegration analysis of the restricted system
```

### Determine the order of lag

```{r}
infocrit <- VARselect(VAR2, lag.max = 4, type = "trend") ##Similar results as in the paper. Lag length of 2

```


### Check the model specification adequacy of the estimated unrestricted VAR in levels

```{r}
VAR_unrestricted <- VAR(VAR2, p = 2, type = "trend")

roots_stability <- roots(VAR_unrestricted)

```



```{r, warning=FALSE}

 varUR.serial <- serial.test(VAR_unrestricted, lags.pt = 17) ## Fail to reject null of multivariate serial correlation


 varUR.serial2 <- serial.test(VAR_unrestricted, type = "BG", lags.bg = 16)  ## Fail to reject null of multivariate serial correlation
 
 
 varUR.arch <- arch.test(VAR_unrestricted, lags.multi = 4,multivariate.only = F) ##Evidence of heteroskedasticity. Look individually
 
 varUR.norm <- normality.test(VAR_unrestricted, multivariate.only = F) ## Evidence of non-normal errors. Look individually

 
 #plot(varUR.serial)

reccusum_test <- stability(VAR_unrestricted,type = "Rec-CUSUM")

 #plot(reccusum_test)


fluctuation_test <- stability(VAR_unrestricted,type = "fluctuation")

 #plot(fluctuation_test)


```



## Impose the number of cointegrating relationships $r$ and execute normalization as necessary.

### Determine the number of cointegrating relationships

```{r}
Johansen_trace <- ca.jo(VAR2, type="trace", K=2, ecdet=c("trend"), spec="longrun")

# test stat < CV where r <=2 : reject null of no cointegrating relationships

Johansen_eig<- ca.jo(VAR2, type="eigen", K=2, ecdet=c("trend"), spec="longrun")

# test stat > CV for r=0 and r <=1. At there r's, we reject null of no coint rel

summary(Johansen_eig)

```




```{r}



VECM_levels <- vec2var(Johansen_eig, r=1)

VECM <- cajorls(Johansen_eig, r = 1)

VECM_levels

```



```{r}
 vecm.fevd <- fevd(VECM_levels) #forecast error variance decomposition
 vecm.norm <- normality.test(VECM_levels)
 vecm.arch <- arch.test(VECM_levels)
 vecm.serial <- serial.test(VECM_levels)
 
```




```{r}
VECModelNew <- VECM(VAR2,lag=2, r=2, estim="ML")

VARModelNew <- VAR(VAR2, p=2, type = "trend", lag.max = 4)

summary(VECModelNew)

```



```{r, echo = FALSE}
VARModelRestricted <- VAR(VAR1, p=2, type = "trend", lag.max = 4)

covariancematrix <- summary(VARModelRestricted)$covres

```




```{r, echo = FALSE}
Brow1 <- c(1,1,0,1,0,0)
Brow2 <- c(0,1,1,1,1,1)
Brow3 <- c(0,0,1,1,1,1)
Brow4 <- c(0,0,0,1,1,1)
Brow5 <- c(0,0,0,0,1,1)
Brow6 <- c(0,0,0,0,0,1)
#m, r, y, p, e, o


B_Matrix <- rbind(Brow1, Brow2, Brow3, Brow4, Brow5, Brow6)

colnames(B_Matrix)<-NULL
rownames(B_Matrix) <- NULL
```



```{r}
 vecm.fevd <- fevd(VECM_levels) #forecast error variance decomposition
 vecm.norm <- normality.test(VECM_levels)
 vecm.arch <- arch.test(VECM_levels)
 vecm.serial <- serial.test(VECM_levels)
 
```







```{r, echo = FALSE}
covariancematrix*B_Matrix*t(B_Matrix)
```

We then obtain a single entry for each row, which we can create our short-run error vector from.

```{r}
ErrorVector_U <- c(0.0001328802, 0.07138726, 2.804883e-05, 0.753182, 0.01135468,  0.02108534)
```





```{r, echo = FALSE}
M_IRF <- irf(VECM_levels, impulse = "oilprice_tr", response = "real_monetaryaggregate_tr",
             n.ahead = 16, ortho = FALSE, runs = 1000)
IR_IRF <- irf(VECM_levels, impulse = "oilprice_tr", response = "interestrate_tr",
             n.ahead = 16, ortho = FALSE, runs = 1000)
GDP_IRF <- irf(VECM_levels, impulse = "oilprice_tr", response = "realGDP_tr",
             n.ahead = 16, ortho = FALSE, runs = 1000)
I_IRF <- irf(VECM_levels, impulse = "oilprice_tr", response = "inflation_tr",
             n.ahead = 16, ortho = FALSE, runs = 1000)
ER_IRF <- irf(VECM_levels, impulse = "oilprice_tr", response = "exchangerate_tr",
             n.ahead = 16, ortho = FALSE, runs = 1000)

M <- plot(M_IRF)
I <- plot(IR_IRF)
G <- plot(GDP_IRF)
In <- plot (I_IRF)
E <- plot(ER_IRF)


#plotIRFGrid(irf, eb, indexes, type, bands)

#grid.arrange(M, I, G, In, E)


```



